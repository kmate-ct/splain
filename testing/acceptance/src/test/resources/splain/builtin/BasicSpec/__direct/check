newSource1.scala:13: error: implicit error;
!I e: splain.acceptance.builtin.StaticBasicSpec.ImplicitChain.II
ImplicitChain.g invalid because
!I impPar3: ImplicitChain.I1
――ImplicitChain.i1 invalid because
  !I impPar7: ImplicitChain.I3
  implicitly[II]
            ^
newSource1.scala:6: error: type mismatch;
  splain.acceptance.builtin.StaticBasicSpec.FoundReq.L|splain.acceptance.builtin.StaticBasicSpec.FoundReq.R
  f(new L)
    ^
newSource1.scala:4: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
      splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
        splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
          splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
            splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
              splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[String]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
  implicitly[VeryLong[
            ^
newSource1.scala:4: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
      splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
        splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
          splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
            splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
              splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[String]
              ]
            ]
          ]
        ]
      ]
    ]
  ] {
    type A = Int;
    type B = Int;
    type C = Int;
    type D = Int;
    type E = Int;
    type F = Int;
    type G = Int;
    type H = Int
  }
  implicitly[VeryLong[
            ^
newSource1.scala:4: error: implicit error;
!I e:
  (
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[Int],
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
      splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
        splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
          splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
            splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
              splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                  splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[Int]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  )
  implicitly[
            ^
newSource1.scala:16: error: type mismatch;
  (
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[Int],
    splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
      splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
        splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
          splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
            splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
              splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[
                  splain.acceptance.builtin.StaticBasicSpec.Long.VeryLong[Int|String]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  )
  ) = x
      ^
newSource1.scala:11: error: type mismatch;
  B.this.t1.type|B.this.t.TT
    val t2: t.TT = t1
                   ^
newSource1.scala:7: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Bounds.F[
    splain.acceptance.builtin.StaticBasicSpec.Bounds.Arg
  ]
Bounds.g invalid because
nonconformant bounds;
[splain.acceptance.builtin.StaticBasicSpec.Bounds.Arg, Nothing]
[A <: Bounds.Base, B]
  implicitly[F[Arg]]
            ^
newSource1.scala:4: error: implicit error;
!I ec: scala.concurrent.ExecutionContext
  Cannot find an implicit ExecutionContext. You might add
  an (implicit ec: ExecutionContext) parameter to your method.

  The ExecutionContext is used to configure how and on which
  thread pools asynchronous tasks (such as Futures) will run,
  so the specific ExecutionContext that is selected is important.

  If your application does not define an ExecutionContext elsewhere,
  consider using Scala's global ExecutionContext by defining
  the following:

  implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global

  long
  ^
newSource1.scala:10: error: implicit error;
!I e: String
f invalid because
!I impPar4:
  List[
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
    )
    ::::
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.Short ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.Short
    )
    ::::
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
    )
    ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
  ]
   (No implicit view available from Int => splain.acceptance.builtin.StaticBasicSpec.InfixBreak.T2.)

  implicitly[String]
            ^
newSource1.scala:11: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.DeepHole.C1[
    splain.acceptance.builtin.StaticBasicSpec.DeepHole.T3[
      splain.acceptance.builtin.StaticBasicSpec.DeepHole.T1[List[String], ?],
      splain.acceptance.builtin.StaticBasicSpec.DeepHole.T2[
        splain.acceptance.builtin.StaticBasicSpec.DeepHole.Id,
        splain.acceptance.builtin.StaticBasicSpec.DeepHole.C4,
        ?
      ],
      ?
    ]
  ]
  implicitly[C1[T3]]
            ^
newSource1.scala:9: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Aux.F.Aux[
    splain.acceptance.builtin.StaticBasicSpec.Aux.C,
    splain.acceptance.builtin.StaticBasicSpec.Aux.D
  ]
Aux.f invalid because
!I impPar10: Aux.C
  implicitly[F.Aux[C, D]]
            ^
newSource1.scala:11: error: type mismatch;
  splain.acceptance.builtin.StaticBasicSpec.Refined.A with
  splain.acceptance.builtin.StaticBasicSpec.Refined.B with
  splain.acceptance.builtin.StaticBasicSpec.Refined.E|splain.acceptance.builtin.StaticBasicSpec.Refined.C with
  splain.acceptance.builtin.StaticBasicSpec.Refined.F|<none> {
    type X = Int|String;
    type Y = String;
    type Z = <none>|String
  }
  f(x)
    ^
newSource1.scala:10: error: implicit error;
!I e: splain.acceptance.builtin.StaticBasicSpec.Refined.Node{type T = _$1} forSome { type _$1 <: Int }
  implicitly[NodeLt[Int]]
            ^
newSource1.scala:25: error: type mismatch;
  C.X.Y.T|B.X.Y.T
  f(x: C.X.Y.T)
     ^
newSource1.scala:6: error: type mismatch;
  Int|(=> splain.acceptance.builtin.StaticBasicSpec.Foo.A) => splain.acceptance.builtin.StaticBasicSpec.Foo.B
  f(1: Int)
     ^
newSource1.scala:3: error: type mismatch;
  String|Tuple1[String]
  val a: Tuple1[String] = "Tuple1": String
                                  ^
newSource1.scala:7: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.SingleImp.a.type ***
  splain.acceptance.builtin.StaticBasicSpec.SingleImp.b.type
  implicitly[a.type *** b.type]
            ^
newSource1.scala:8: error: implicit error;
!I e: a.type *** b.type
    implicitly[a.type *** b.type]
              ^
newSource1.scala:6: error: implicit error;
!I e: a.type *** b.type
    implicitly[a.type *** b.type]
              ^
newSource1.scala:5: error: implicit error;
!I ev: scala.math.Ordering[Object]
  No implicit Ordering[Object] found to build a SortedSet[Object]. You may want to upcast to a Set[Int] first by calling `unsorted`.

Ordering.ordered invalid because
!I asComparable: Object => Comparable[Any]
  No implicit view available from Object => Comparable[_ >: Object].

Ordering.comparatorToOrdering invalid because
!I cmp: java.util.Comparator[Object]
    ms.map(_ => o)
          ^
newSource1.scala:9: error: implicit error;
!I e: List[splain.acceptance.builtin.StaticBasicSpec.a.TypeA]
   (No implicit view available from Int => splain.acceptance.builtin.StaticBasicSpec.a.TypeA.)

        implicitly[List[TypeA]]
                  ^
